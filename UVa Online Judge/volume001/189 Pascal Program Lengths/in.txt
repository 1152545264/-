program yzhch(input,output);
var
l,r:real;
const
pi=3.14159
begin
readln(r);
l:=2*pi*r;
writeln('l=',l);
end.
~~qiuqiu

PROGRAM SAMPLEINPUT;

VAR
  TEMP : RECORD
    FIRST, SECOND : REAL;
    END;

BEGIN {Ignore this }
TEMP.FIRST := 5.0E-2;
READLN (TEMP.SECOND); 
WRITELN ('THE ANSWER IS', TEMP.FIRST * TEMP.SECOND : 7 : 3)
END.
~~A. N. Onymous    

program test;
VAR
ch:array['a' .. 'z']of Char;
BEGIN{Ignore 'like a
string'}
Temp:=2;
WRITELN ('''', TEMP.FIRST <= TEMP.SECOND : 7 : 3)
WRITELN ('''a is b''s', TEMP.FIRST <> TEMP.SECOND : 7 : 3)
iden:=($abFe90+1e-90)*2;
END.
~~bleed1979

begin
    comment Algol program print the primes less than 1000 using the 
            sieve method.;
    Boolean array sieve[2:1000];
    integer p, count;

    comment Eliminate the multiples of the argument prime number;
    procedure eliminate(p);
        integer p;
        begin
            integer i;
            for i := 2*p step p until 1000 do
                sieve[i] := false
        end;

    comment Clear the sieve.;
    integer i;
    for i := 2 step 1 until 1000 do
        sieve[i] := true;

    comment Find the primes in range.;
    for i := 2 step 1 until 1000 do
        if sieve[i] then
            eliminate(i);

    comment Print the results, 10 per line.;
    p := 2;
    for count := 0 while p <= 1000 do begin
        comment This construct is similar to a do .. while built with a goto.;
        makeline:
            if sieve[p] then begin
                outinteger(1,p);
                outstring(1,' ');
                count := count + 1
            end;
            p := p + 1;
            if p <= 1000 & count < 10 then goto makeline;
        outstring(1,'\n')
    end

end
~~Algol

begin 
writeln('~~~~~~'); 
{~~~~~~~~~~~~~} 
end. 
~~anonimus

program test;
VAR
ch : array [1..20] of Char;
BEGIN {Ignore 'like a string'}
Temp := 2;
iden := $abFe90;
_iden_ := 1e-90;
END.
~~Jan

program test;
const
pi_7890=899;
var
a_indent_ : real;
begin
a_indent_:=pi_7890;
end;
~~qiuqiu
