// Crypt Kicker II （解密 II）
// PC/UVa IDs: 110304/850, Popularity: A, Success rate: average Level: 2
// Verdict: Accepted
// Submission Date: 2011-05-23
// UVa Run Time: 0.016s
//
// 版权所有（C）2011，邱秋。metaphysis # yeah dot net

#include <iostream>
#include <vector>
#include <sstream>
#include <iterator>

using namespace std;

void printPlain(string cipher)
{
    for (int m = 0; m < encrypted.size(); m++)
    {
        for (int n = 0; n < encrypted[m].size(); n++)
        {
            string tmp = encrypted[m][n];
            for (int j = 0; j < tmp.length(); j++)
                cout << cipher[tmp[j] - 'a'];
            if (n < encrypted[m].size() - 1)
                cout << " ";
        }

        cout << endl;
    }
}

void decipher()
{
    string cipher(26, '*');
    for (int i = 0; i < encrypted.size(); i++)
    {
        // 密文单词数量和明文单词数量相等才继续比较
        if (encrypted[i].size() != plain.size())
            continue;

        // 密文各单词长度与明文各单词长度相同才继续予以比较
        bool allLengthMatch = true;
        for (int j = 0; j < encrypted.size(); j++)
            if (encrypted[i][j].length() != plain[j].length())
            {
                allLengthMatch = false;
                break;
            }

        // 各单词长度相同，尝试匹配
        if (allLengthMatch)
        {
            // 保存当前密码，以便不能匹配时恢复
            string backup = cipher;
            bool matched = true;
            for (int k = 0; k < plain.size(); k++)
            {
                string e = encrypted[i][k];
                string p = plain[k];

                for (int m = 0; m < e.length(); m++)
                    // 若当前密文字母无对应明文文字母匹配，
                    // 则将密文字母与明文字母匹配。
                    if (cipher[e[m] - 'a'] == '*')
                    {
                        cipher[e[m] - 'a'] = p[m];
                    }
                    else
                    {
                        // 若已有明文字母与该密文字母相匹配，则检查需要
                        // 匹配的密文是否与当前相同，若不同，则表示有冲突。
                        if (cipher[e[m] - 'a'] != p[m])
                        {
                            matched = false;
                            break;
                        }
                    }

                if (!matched)
                    break;
            }

            // 满足所有匹配，按当前 cipher 输出密文，否则还原密码为初始状态。
            if (matched)
            {
                printPlain(cipher);
                return;
            }
            else
                cipher = backup;
        }
    }

    // 无解。
    cout << "No solution." << endl;
}

vector < vector < string > > encrypted;
vector < string > plain;

int main(int ac, char *av[])
{
    string word, line;
    int cases;

    // 将明文拆分成单词。
    istringstream iss("the quick brown fox jumps over the lazy dog");
    while (iss >> word)
        plain.push_back(word);

    // 读入数据组数。
    cin >> cases;
    cin.ignore();

    // 忽略空行。
    getline(cin, line);
    while (cases--)
    {
        encrypted.clear();

        // 读入密文，并拆分成单词。
        while (getline(cin, line), line.length() > 0)
        {
            // 必须将输入字符串流的标志清空才能进行新的输入。
            iss.clear();
            iss.str(line);
            vector < string > tmp;
            while (iss >> word)
                tmp.push_back(word);

            encrypted.push_back(tmp);

        }

        decipher();

        if (cases > 0)
            cout << endl;
    }

    return 0;
}
